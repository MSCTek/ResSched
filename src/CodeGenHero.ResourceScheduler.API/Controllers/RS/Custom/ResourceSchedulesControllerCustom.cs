// <auto-generated> - Template:WebApiControllerPartialMethods, Version:1.1, Id:54f0612b-5235-437d-af2d-0b75efa68630
using CodeGenHero.Repository;
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Entity;
using System.Linq;
using System.Net;
using System.Text;
using dtoRS = CodeGenHero.ResourceScheduler.DTO.RS;
using entRS = CodeGenHero.ResourceScheduler.Repository.Entities.RS;

namespace CodeGenHero.ResourceScheduler.API.Controllers.RS
{
    public partial class ResourceSchedulesRSController : RSBaseApiController
    {
        partial void RunCustomLogicBeforeInsert(ref dtoRS.ResourceSchedule dtoItem, ref HttpStatusCode httpStatusCode, ref string message)
        {   // Business rule - check to see if the requested resource times conflict with what is reserved in the DB.
            List<string> messages = new List<string>();
            if (!Validate(ref dtoItem, ref messages)) { httpStatusCode = HttpStatusCode.PreconditionFailed; message = String.Join(",", messages); }
        }

        partial void RunCustomLogicBeforeUpdate(ref dtoRS.ResourceSchedule dtoItem, ref HttpStatusCode httpStatusCode, ref string message)
        {   // Business rule - check to see if the requested resource times conflict with what is reserved in the DB.
            List<string> messages = new List<string>();
            if (!Validate(ref dtoItem, ref messages)) { httpStatusCode = HttpStatusCode.PreconditionFailed; message = String.Join(",", messages); }
        }

        private bool Validate(ref dtoRS.ResourceSchedule dtoItem, ref List<string> messages)
        {
            //fields need to be filled in and the end date/time needs to be after the before date/time

            //check that we have a reserved for field
            if (string.IsNullOrEmpty(dtoItem.ReservedForUser))
            {
                messages.Add("Please note who/what the reservation is for!");
            }

            if (dtoItem.ReservationStartDateTime == DateTime.MinValue || dtoItem.ReservationEndDateTime == DateTime.MinValue)
            {
                messages.Add("We are having trouble making your reservation. Please let an admin know.");
            }

            //reservations should start before they end
            if (dtoItem.ReservationStartDateTime >= dtoItem.ReservationEndDateTime)
            {
                messages.Add("Your reservation should begin before it ends!");
            }

            //lastly, make sure there is no conflict with existing reservations
            var selectedDate = new DateTime(year: dtoItem.ReservationStartDateTime.Year, month: dtoItem.ReservationStartDateTime.Month, day: dtoItem.ReservationStartDateTime.Day);
            var HourlySchedules = BuildHourlySchedules(selectedDate: selectedDate, resourceId: dtoItem.ResourceId);
            foreach (var h in HourlySchedules)
            {
                if (h.IsReserved && h.ResourceSchedule != null)
                {
                    //if the new/edited reservation is inbetween and of the existing reservations...
                    if (dtoItem.ReservationStartDateTime <= h.Hour && dtoItem.ReservationEndDateTime >= h.Hour)
                    {
                        //check if we are currently editing this record.
                        if (dtoItem.Id != h.ResourceSchedule.Id)
                        {
                            messages.Add("Your reservation conflicts with an existing reservation.");
                        }
                    }
                }
            }

            return messages.Count == 0;
        }

        public List<HourlySchedule> HourlySchedules { get; set; }

        public static List<int> Hours = new List<int>() { 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 };

        public List<HourlySchedule> BuildHourlySchedules(DateTime selectedDate, Guid resourceId)
        {
            var hourlySchedules = new List<HourlySchedule>();
            var schedules = Repo.RSDataContext.ResourceSchedules.Where(
                x => x.ReservationStartDateTime >= selectedDate 
                && x.ReservationStartDateTime <= selectedDate.AddDays(1));
            
            foreach (var h in Hours)
            {
                var hour = selectedDate.AddHours(h);
                var sched = schedules.Where(x => x.ReservationStartDateTime <= hour && x.ReservationEndDateTime >= hour).FirstOrDefault();

                hourlySchedules.Add(new HourlySchedule()
                {
                    Hour = hour,
                    ResourceSchedule = sched
                });
            }
            return hourlySchedules;
        }

        public class HourlySchedule
        {
            public DateTime Hour { get; set; }
            public bool IsReserved { get { return ResourceSchedule == null ? false : true; } }
            public entRS.ResourceSchedule ResourceSchedule { get; set; } = new entRS.ResourceSchedule();
        }


        //partial void RunCustomLogicAfterInsert(ref entRS.ResourceSchedule newDBItem, ref IRepositoryActionResult<entRS.ResourceSchedule> result) {}

        //partial void RunCustomLogicAfterUpdatePatch(ref entRS.ResourceSchedule updatedDBItem, ref IRepositoryActionResult<entRS.ResourceSchedule> result) {}

        //partial void RunCustomLogicAfterUpdatePut(ref entRS.ResourceSchedule updatedDBItem, ref IRepositoryActionResult<entRS.ResourceSchedule> result) {}


        ///// <summary>
        ///// A sample implementation of custom logic used to either manipulate a DTO item or include related entities.
        ///// </summary>
        ///// <param name="dbItem"></param>
        ///// <param name="id"></param>
        ///// <param name="numChildLevels"></param>
        // partial void RunCustomLogicOnGetEntityByPK(ref entRS.ResourceSchedule dbItem, System.Guid id, int numChildLevels)
        // {
        // if (numChildLevels > 1)
        // {
        // int[] orderLineItemIds = dbItem.OrderLineItems.Select(x => x.OrderLineItemId).ToArray();

        // var lineItemDiscounts = Repo.RSDataContext.OrderLineItemDiscounts.Where(x => orderLineItemIds.Contains(x.OrderLineItemId)).ToList();

        // foreach (var lineItemDiscount in lineItemDiscounts)
        // { // Find the match and add the item to it.
        // var orderLineItem = dbItem.OrderLineItems.Where(x => x.OrderLineItemId == lineItemDiscount.OrderLineItemId).FirstOrDefault();

        // if (orderLineItem == null)
        // {
        // throw new System.Data.Entity.Core.ObjectNotFoundException($"Unable to locate matching OrderLineItem record for {lineItemDiscount.OrderLineItemId}."
        // }

        // orderLineItem.LineItemDiscounts.Add(lineItemDiscount);
        // }
        // }

        // }

        ///// <summary>
        ///// A sample implementation of custom logic used to filter on a field that exists in a related, parent, table.
        ///// </summary>
        ///// <param name="dbItems"></param>
        ///// <param name="filterList"></param>
        //partial void RunCustomLogicAfterGetQueryableList(ref IQueryable<entRS.ResourceSchedule> dbItems, ref List<string> filterList)
        //{
        //	var queryableFilters = filterList.ToQueryableFilter();
        //	var myFilterCriterion = queryableFilters.Where(y => y.Member.ToLowerInvariant() == "<myFieldName>").FirstOrDefault(); // Examine the incoming filter for the presence of a field name which does not exist on the target entity.

        //	if (myFilterCriterion != null)
        //	{   // myFieldName is a criterion that has to be evaluated at a level other than our target entity.
        //		dbItems = dbItems.Include(x => x.myFKRelatedEntity).Where(x => x.myFKRelatedEntity.myFieldName == new Guid(myFilterCriterion.Value));
        //		queryableFilters.Remove(myFilterCriterion);  // The evaluated criterion needs to be removed from the list of filters before we invoke the ApplyFilter() extension method.
        //		filterList = queryableFilters.ToQueryableStringList();
        //	}
        //}
    }
}
